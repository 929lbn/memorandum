### JVM分代 
#### 为什么进行分代？ 
如果不对对象的存活时间进行区分，那意味着每一次垃圾回收都是对整个对空间进行回收，也就需要在每次回收时**遍历所有对象**。但对于生命周期长得对象来说，这种遍历就是多余的、无效的。因此分代可以把不同生命周期的对象放在不同代上，在不同代上采用最适合它的垃圾回收方式进行回收。
* * *
### GC算法
#### 复制算法(新生代) 
将内存分为大小相等的两块，每次只使用其中一块。当这块内存用完了，将还存活的对象复制到另一块内存里，再把已使用的内存空间一次清理掉。这样每次都对整个半区进行内存回收。代价是相当于把内存缩小为原来的一半。  
这种方式主要用在**回收新生代** 。HOTSPOT中并不是划分为1:1的两块，而是分为较大的Eden空间和两块较小的Survivor空间。回收时，将Eden和Survivor空间中还存活的对象都复制到另一块Survivor中，再清理掉Eden和刚才用过的Survivor空间。(E:S = 8:1)
> 之所以将E:S设置的这么大，是因为绝大多数对象的生存期都很短(据IBM统计约98%)，但确实无法保证每次回收都有不多于10%的对象存活(极端情况，如实例化了大量重写了Finalize方法的类)，当Survivor不够时，需要依赖**老年代**进行分配担保，即将装不下的对象移入老年代。  

#### 标记-整理算法(老年代) 
标记需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

* * *  
### 内存分配  
- 对象优先在Eden分配。当Eden空间不足时，发生一次MinorGC。
- 大对象(需要大量连续空间的对象，如超长字符串及数组)经常出现将导致内存在尚有不少空间的时候就提前触发垃圾收集以获取足够的连续空间。 可通过参数设置阈值，另大于该值的对象直接在老年代分配。避免在Eden及Survivor区发生大量内存复制。
- 每个对象有一个“对象年龄”计数器。若再第一次MinorGC后仍存活并能被Survivor区容纳的话，将被移动到Survivor区中，年龄设为1。之后每在Survivor中活过一次GC，年龄加一。当增加到一定值(默认15)后，晋升到老年代。 
- Survivor中同年龄(e.g. age=n)的对象的大小总和>Survivor空间的一半，年龄>=n的对象可直接进入老年代，无需等到年龄达到阈值。 
